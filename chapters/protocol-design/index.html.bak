<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="article:modified_time" content="2025-02-04T10:43:06+00:00" /><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="Bibliography" href="../../bibliography.html" /><link rel="prev" title="Sequences" href="../behavioral-topics/topics/sequences/index.html" />

    <!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
        <title>Protocol design - Practical Alloy</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../_static/practicalalloy.css?v=2ee171b3" />
    <link crossorigin="anonymous" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" rel="stylesheet" type="text/css" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #2a5adf;
  --color-brand-content: #2a5adf;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Practical Alloy</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Practical Alloy</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Preface</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about-alloy/index.html">About Alloy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about-book/index.html">About this book</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../structural-modeling/index.html">Structural modeling</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../structural-topics/index.html">Advanced topics</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Advanced topics</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/subset-signatures/index.html">Subset signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/enumerations/index.html">Enumeration signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/commands/index.html">Commands in detail</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/visualization/index.html">Visualization customization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/nary-relations/index.html">Higher-arity relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/evaluator/index.html">The instance evaluator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/bestiary/index.html">Arrow multiplicity constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/type-system/index.html">Type system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/modules/index.html">Module system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/ordering/index.html">The predefined <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">ordering</span></code> module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/relational-logic/index.html">A relational logic primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/model-finding/index.html">Model finding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/testing-instances/index.html">Encoding test instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/recursion/index.html">Handling recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/integers/index.html">Working with integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../structural-topics/topics/signature-facts/index.html">Signature facts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../behavioral-modeling/index.html">Behavioral modeling</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../behavioral-topics/index.html">Advanced topics</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Advanced topics</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/temporal-logic/index.html">A temporal logic primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/mutable-toplevel-signatures/index.html">Mutable top-level signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/pointwise-effects/index.html">Pointwise effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/macros/index.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/meta/index.html">Meta-capabilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/event-depiction/index.html">An idiom for event depiction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/scenarios/index.html">Encoding trace scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/evaluator/index.html">The trace evaluator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/fairness/index.html">Safety, liveness, and fairness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/inductive-invariants/index.html">Inductive invariants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../behavioral-topics/topics/sequences/index.html">Sequences</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Applications</span></p>
<ul class="current">
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Protocol design</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../../_sources/chapters/protocol-design/index.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="protocol-design">
<span id="id1"></span><h1>Protocol design<a class="headerlink" href="#protocol-design" title="Link to this heading">¶</a></h1>
<p id="index-0">In this chapter we will explain how to specify and analyze a
distributed protocol using Alloy. We will use a very simple example of
a leader election protocol. The aim of a leader election protocol is
to designate one node in a network as the <em>organizer</em> or <em>leader</em> of
some distributed task. Nodes are initially unaware of which node will
play that role, but after running the protocol all nodes should
recognize the same node as leader. Many leader election
protocols exist: here we will use a well-known version that can be
used to elect a leader in a network of nodes organized in a ring, and
where nodes also have unique comparable identifiers.</p>
<p>This protocol was proposed by Chang and Roberts <a class="reference internal" href="../../bibliography.html#cacm79" id="id2"><span>[CACM79]</span></a>
and roughly operates as follows: the goal is to elect as leader the
node with the highest identifier; each node starts by sending its own
identifier to its successor in the ring; upon receiving an identifier, a node only
forwards it if it is higher than its own; a node receiving back its
own identifier designates itself as leader; finally the leader
broadcasts its newly found role to the network. In our specification
we will start by omitting this second last phase of the protocol and will only be concerned
with the fundamental property of a leader election protocol:
eventually exactly one node will designate itself as the
leader.</p>
<section id="specifying-the-network-configuration">
<h2>Specifying the network configuration<a class="headerlink" href="#specifying-the-network-configuration" title="Link to this heading">¶</a></h2>
<p id="index-1">When designing a distributed protocol, we should start by specifying
the network configurations in which it is supposed to operate. In this
case, the protocol operates in a ring network of nodes with unique
identifiers. Notice that many network configurations satisfy
this requirement: we could have rings of different size, and for the
same size, different assignments of the unique identifiers to the
nodes (the relevant fact here is the relative order in which the
identifiers appear in the network). The verification of the expected
properties of the protocol should take into account all possible
different configurations (up to the specified bound on the ring
size). The network configuration, although arbitrary, does not change
during the execution of the protocol. As such, it will be
specified with immutable signatures and fields.</p>
<p>Unlike some formal specification languages, Alloy has no
pre-defined notion of <em>process</em> or <em>node</em>. These have to be explicitly
specified, by declaring a signature. Since the network of nodes forms
a ring, a binary relation that associates each node with its
immediate successor in the ring should also be declared.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Recall that binary relations should be declared as fields inside the
domain signature. In the declaration of field <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">succ</span></code> the
multiplicity <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">one</span></code> is used to ensure that each node has exactly
one successor in the ring.  As usual in Alloy, we can immediately start
validating our specification by inspecting possible instances generated using a
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">run</span></code> command.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example</span> <span class="o">{}</span>
</pre></div>
</div>
<p>By iterating over the returned instances with <span class="guilabel">New</span> we could
get the following instance, which is of course not a valid ring.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_1/leaderelection.als#L9-L14"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance114.png" style="width: 400px;" />
</a>
<p id="index-2">In addition to requiring each node to have exactly one successor, a simple way to ensure that a network forms a ring is to require that
every node is reachable from any other node. Given a node <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>,
to determine the set of nodes reachable from <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> via relation
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">succ</span></code> we can use expression
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.^</span><span class="n">succ</span></code>. This expression makes use of the composition (<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="o">.</span></code>) and transitive closure (<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="o">^</span></code>) operators already presented in the <a class="reference internal" href="../structural-modeling/index.html#structural-modeling"><span class="std std-ref">Structural modeling</span></a> chapter. The constraint that <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">succ</span></code> forms a ring can thus be specified in a fact as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">ring</span> <span class="o">{</span>
  <span class="c1">// succ forms a ring</span>
  <span class="k">all</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">succ</span>
<span class="o">}</span>
</pre></div>
</div>
<p>An alternative specification of fact <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">ring</span></code> is to require that the set of all
nodes (denoted by <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code>) is reachable from every node.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">ring</span> <span class="o">{</span>
  <span class="c1">// succ forms a ring</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">Node</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">succ</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If we now iterate over all instances returned by command <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example</span></code> we will get the 3 possible rings with up to 3 nodes and a configuration without any node, which is also allowed by our specification. The limit of 3 is due to the implicit command scope of 3 atoms per top-level signature. As an example we show the ring with 3 nodes.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_2/leaderelection.als#L12-L19"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance24.png" style="width: 400px;" />
</a>
<p>To enforce that we have at least one node that can be elected we can add the following fact.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">some_node</span> <span class="o">{</span>
  <span class="c1">// at least one node</span>
  <span class="k">some</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-3">Besides being organized in a ring, nodes must also have unique identifiers. Since we are going to need to compare identifiers, one possibility would be to just use integers to represent them. However, besides being totally ordered, integers carry additional semantics that is not necessary here. In particular, integers support arithmetic operations that will not be required in this example. When developing a formal specification it is good practice to be as abstract as possible and use the simplest structure that fulfills our needs. Also, the analysis of Alloy specifications with integers has some subtleties which makes it better to avoid, unless strictly necessary. As such, we will introduce a signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Id</span></code>, to denote identifiers, and declare that this signature is totally ordered using a call to module <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">util</span><span class="o">/</span><span class="n">ordering</span></code> at the top of the file. Doing so implicitly extends the model with a binary relation <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">next</span></code> that given an identifier will yield the next identifier in the total order, two singleton signatures to denote the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">first</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">last</span></code> identifiers of the order, and a binary predicate <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">gt</span></code> to compare if the first argument is greater than the second. All identifiers but one (the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">last</span></code>) have a <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">next</span></code>.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="nn">util</span><span class="o">/</span><span class="n">ordering</span><span class="o">[</span><span class="n">Id</span><span class="o">]</span>

<span class="kd">sig</span> <span class="nc">Id</span> <span class="o">{}</span>
</pre></div>
</div>
<p>Having our identifiers totally ordered, we can now declare a field <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">id</span></code> inside signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code>, to associate each node with its identifier.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">id</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Id</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-4">To ensure that identifiers are unique it suffices to require <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">id</span></code> to be injective, which can be done as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">unique_ids</span> <span class="o">{</span>
  <span class="c1">// ids are unique</span>
  <span class="k">all</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="k">lone</span> <span class="n">id</span><span class="o">.</span><span class="n">i</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If we can now create a new <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example3</span></code> command to ask for all configurations with exactly 3 nodes and 3 identifiers, as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example3</span> <span class="o">{}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Id</span>
</pre></div>
</div>
<p id="index-5">Setting an exact scope over identifiers is actually redundant because
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">util</span><span class="o">/</span><span class="n">ordering</span></code> always imposes an exact scope. If we iterate over all instances
with <span class="guilabel">New</span>, we will get the two only (truly) different configurations
with this scope: one where the identifiers increase as we move forward in the
ring, and another where they decrease. The latter is depicted below (notice the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">next</span></code>, <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">prev</span></code>, <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">first</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">last</span></code> elements introduced by <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">util</span><span class="o">/</span><span class="n">ordering</span></code>).
This illustrates the power of Alloy’s symmetry breaking, which in this case
prevents the return of any other instance (that necessarily would be isomorphic
to one of these two).</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_3/leaderelection.als#L30-L38"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance33.png" style="width: 400px;" />
</a>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-file-badge" viewBox="0 0 16 16" aria-hidden="true"><path d="M2.75 1.5a.25.25 0 0 0-.25.25v11.5c0 .138.112.25.25.25h3.5a.75.75 0 0 1 0 1.5h-3.5A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8a1.75 1.75 0 0 1 1.508.862.75.75 0 1 1-1.289.768.25.25 0 0 0-.219-.13h-8Z"></path><path d="M8 7a3.999 3.999 0 0 1 7.605-1.733 4 4 0 0 1-1.115 4.863l.995 4.973a.75.75 0 0 1-.991.852l-2.409-.876a.248.248 0 0 0-.17 0l-2.409.876a.75.75 0 0 1-.991-.852l.994-4.973A3.994 3.994 0 0 1 8 7Zm4-2.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm0 6.5c-.373 0-.745-.051-1.104-.154l-.649 3.243 1.155-.42c.386-.14.81-.14 1.196 0l1.155.42-.649-3.243A4.004 4.004 0 0 1 12 11Z"></path></svg> Alloy model</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Full model for the section</div>
<p class="sd-card-text">Download and explore the files relevant for the model at this point of the book.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference external" href="https://github.com/practicalalloy/models/tree/main/protocol-design/specifying-the-network-configuration"><span>https://github.com/practicalalloy/models/tree/main/protocol-design/specifying-the-network-configuration</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
The predefined <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">ordering</span></code> module</div>
<p class="sd-card-text">Learn more about the predefined module that we have used to impose a total order on the identifiers.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../structural-topics/topics/ordering/index.html#ordering"><span class="std std-ref">The predefined ordering module</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Working with integers</div>
<p class="sd-card-text">Learn what are the caveats of using integers and how to properly address them in Alloy.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../structural-topics/topics/integers/index.html#integers"><span class="std std-ref">Working with integers</span></a></div>
</div>
</section>
<section id="specifying-the-protocol-dynamics">
<span id="specifying-protocol-dynamics"></span><h2>Specifying the protocol dynamics<a class="headerlink" href="#specifying-the-protocol-dynamics" title="Link to this heading">¶</a></h2>
<p id="index-6">The coordination between the different nodes in this distributed protocol, like in many others, is achieved by means of message passing. Again, likewise for nodes, Alloy has no special support for message passing, so all the relevant concepts have to be specified from scratch. In this phase of the protocol messages are just node identifiers, so there is no need to add a signature to model those, and we can use signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Id</span></code> directly to represent messages. To capture the incoming and outgoing messages we can declare mutable binary fields inside signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code>, to associate each node with the set of identifiers it has received or that need to be sent, respectively. Using sets for the mailboxes is an abstraction that allows us to verify that the protocol is correct even if messages are transmitted out of order. In this protocol the same message is never sent twice by each node, so we also don’t need to account for multiple copies of the same message.
As we have seen in the <a class="reference internal" href="../behavioral-modeling/index.html#behavioral-modeling"><span class="std std-ref">Behavioral modeling</span></a> chapter, to declare a mutable field the keyword <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">var</span></code> should be used.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">id</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Id</span><span class="p">,</span>
  <span class="k">var </span><span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Id</span><span class="p">,</span>
  <span class="k">var </span><span class="n">outbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Id</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-7">We also need to distinguish the nodes that have been elected as leaders. To do so we can declare a mutable signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> that is a subset of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code>.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">var </span><span class="kd">sig</span> <span class="nc">Elected</span> <span class="k">in</span> <span class="nc">Node</span> <span class="o">{}</span>
</pre></div>
</div>
<p>Note that, on purpose, we did not impose a multiplicity <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">lone</span></code> in this declaration, because that constraint, that at most one node is elected leader, is one of the key assertions we will want to verify to be a consequence of the protocol dynamics, and thus should not be imposed as an assumption upfront.</p>
<p id="index-8">If we now run the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example3</span></code> command we might get the following instance.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_4/leaderelection.als#L34-L45"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance42.png" style="width: 700px;" />
</a>
<p>As we have seen in the <a class="reference internal" href="../behavioral-modeling/index.html#behavioral-modeling"><span class="std std-ref">Behavioral modeling</span></a> chapter, the interface of the visualizer is different when we have mutable elements: it now shows two states of a trace side-by-side, there are several new instance exploration buttons in the toolbar, and a depiction of a path just below those. In this case we have a trace where the same state 0 repeats itself indefinitely, something that is possible since so far we added no restrictions that constrain the behavior of the protocol. We recall that in the depiction of the states, by default, immutable sets and fields (the configuration of the protocol) are shown with solid lines, while mutable ones are shown with dashed lines.</p>
<p>To simplify the visualization, we can configure the theme so that node identifiers, the inbox, and the outbox are shown as node attributes, and change the color of elected nodes to green. Since the elected nodes can now be easily distinguished by color we can also hide the respective textual label. As for the totally ordered identifiers, we will just show the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">next</span></code> relation. The result of this customization will be the following.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_5/leaderelection.als#L34-L45"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance52.png" style="width: 600px;" />
</a>
<p>Something that is clearly wrong in this execution is that in the initial
state nodes already have identifiers in their inboxes and outboxes, and some of them are already elected. To restrict the initial value of these mutable fields we can add the following fact.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">init</span> <span class="o">{</span>
  <span class="c1">// initially inbox and outbox are empty</span>
  <span class="k">no</span> <span class="n">inbox</span> <span class="ow">and</span> <span class="k">no</span> <span class="n">outbox</span>
  <span class="c1">// initially there are no elected nodes</span>
  <span class="k">no</span> <span class="n">Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Since this fact has no temporal connectives
it applies to the initial state of the system. Rerunning the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example3</span></code> command now yields instances such as the following, where the
systems remains indefinitely in a valid initial state.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_6_7/leaderelection.als#L41-L52"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance62.png" style="width: 600px;" />
</a>
<p id="index-9">We can explore additional instances by using the instance exploration buttons in the toolbar. For example, the <span class="guilabel">New Fork</span> button asks the Analyzer for a different trace with the same behavior up to the left-hand side state, but a different outcome of the current transition (a different right-hand side state). By pressing this button we may get the following.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_6_7/leaderelection.als#L54-L70"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance72.png" style="width: 600px;" />
</a>
<p>This trace displays a behavior that should not be allowed in a correct execution of the protocol: in the second state all of a sudden several identifiers appeared in the inbox and outbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node1</span></code>. Moreover, this node was also randomly designated as leader. So far this is allowed because we added no constraints to our specification that restrict how the system can transition from one state to another. If there are no constraints then any transition is possible.</p>
<p id="index-10">As already explained in chapter <a class="reference internal" href="../behavioral-modeling/index.html#behavioral-modeling"><span class="std std-ref">Behavioral modeling</span></a>, the simplest way to constrain the valid transitions is to consider all the possible events that can occur in the system, and for each event specify when it can occur (its <em>guard</em>) and what is its <em>effect</em> on the mutable relations. In our protocol we can distinguish three possible events:</p>
<ul class="simple">
<li><p>a node <em>initiates</em> the execution by sending its own identifier to the next node;</p></li>
<li><p>a node reads and <em>processes</em> an identifier in its inbox, decides whether it should be propagated or discarded and, if it is its own identifier, elects itself as leader;</p></li>
<li><p>the network <em>sends</em> one message in the outbox of a node to the inbox of the next one.</p></li>
</ul>
<p>Alloy has no special keywords to declare events. A common
approach is to declare a predicate for each event, that
specifies its guard and effect, and add a
constraint enforcing that at each possible state only one of those
predicates can hold. Event predicates can also be parametrized, and in our specification they will be parametrized the node where the event occurs.</p>
<p id="index-11">Let’s begin by specifying the <em>initiate</em> event. For each event we should
always start by specifying what is its guard, a constraint on the
current (or pre-) state that determines when can the event occur. To simplify our
specification, for the moment, we will assume that a node is free to initiate (or
re-initiate) the protocol whenever it wants, so in this case there will
be no guard, meaning the event is always possible. Then we should
specify the effect of the event on all mutable relations of the specification:
note that if nothing is said about a particular mutable relation then
its value can change freely when the event occurs. A special effect is
forcing the value of a mutable relation to not change at all,
something known as a <em>frame condition</em>. For example in this event we
will have two frame conditions, since it does not change the value of
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> nor <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>. To specify that a relation does not
change with a logic formula we need to refer to its value in the next
(or post-) state. In Alloy the value of a relation (or relational
expression) in the next state is accessed by appending a prime. So, to
state that, for example, the relation <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> does not change we
could add the constraint <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span></code>. Likewise for
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>. So far, the specification of event initiate looks as
follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate_no_effect</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span>                           <span class="c1">// frame condition on inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                       <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>We now need to specify the effect on relation <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code>. We can
start by specifying its effect on the outbox of the initiating
node. Expression <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code> denotes the set of identifiers in
the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> of node <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> in the current state. The effect
of this event on this set is to add <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>’s own identifier, which
can be specified by <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span></code>. Here we used
the set union operator <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="o">+</span></code> to add the singleton set <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code>
to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code>. Note that requiring <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code> to be present in
the outbox in the next state, which could be specified by <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">id</span>
<span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span></code>, is not sufficient, as it would allow identifiers other than <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code>
to be freely removed or added from <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code>. Having specified
the effect on the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> we now need to specify the
effect on the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> of all other nodes. Again, if nothing is
said about those, they will be allowed to vary freely. Of course this
event should not modify the outboxes of other nodes, something we
could specify with constraint <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span>
<span class="n">m</span><span class="o">.</span><span class="n">outbox</span></code>, that quantifies over all nodes except the initiating one. The final specification of our event looks as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate_no_guard</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>                <span class="c1">// effect on n.outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>    <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span>                             <span class="c1">// frame condition on inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                         <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-12">To validate our first event we can impose a restriction stating that,
for the moment, this is the only event that can occur, and inspect the
possible instances to see if the system behaves as expected. To
specify such a restriction we need the temporal logic operator
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">always</span></code> to enforce a formula to be true at all
possible states. In particular, to enforce that, at every possible
state, one of the nodes initiates the protocol, the following
fact can be added to the specification.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">always_initiate</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span><span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">initiate_no_guard</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Running command <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example3</span></code> yields the following trace, where
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node2</span></code> initiates the protocol and then nothing else happens.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_8/leaderelection.als#L63-L79"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance82.png" style="width: 600px;" />
</a>
<p id="index-13">On first glance, this may seem like an invalid trace, given that we
required that at every state one node initiates the protocol. However,
if we look closely at our specification of event <em>initiate</em> we
can see that it also holds true in a state where a node already has
its own identifier in the outbox, which
will remain in the outbox. Our specification did not had a guard forbidding
this occurrence of the event, and the effect <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span>
<span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span></code> is also true if <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code> is already in
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code> and in <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span></code>.</p>
<p>To address this issue we could add a guard like <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span></code> to predicate <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">initiate_no_guard</span></code>.  However, this
only forbids a node from initiating the protocol if it’s own
identifier is in its outbox at that particular moment. This means that, once we
include an event to send messages and this identifier leaves the
outbox, a node will be able to re-initiate the protocol. In principle, this does not
pose any problem concerning the correctness of this particular
protocol, but if we really wanted each node to initiate the protocol
only once we would need to strengthen this guard.</p>
<p>One possibility would be to add a field to record at which phase of
the protocol execution each node is in, and allow this event only when
a node is in an “uninitiated” phase. This would be the common approach
in most formal specification languages. However, with Alloy we have a
more direct alternative. Since there is no special language to specify
events and they are specified by arbitrary logic formulas, we are free
to use temporal operators to specify guards or effects. By contrast,
in most formal specification languages we can only specify the
relation between the pre- and post-state.</p>
<p id="index-14">In this case we could, for example, use the temporal operator
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">historically</span></code>, that checks if something was always true in the
past up to the current state, to only allow <em>initiate</em> to occur
if the node’s identifier was never in its outbox. The specification of
our event would look as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>          <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>                <span class="c1">// effect on n.outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>    <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span>                             <span class="c1">// frame condition on inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                         <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-15">Unfortunately, after adding this guard our command will
return no trace, meaning there are no behaviors that satisfy our
constraints. This happens because we are currently not
allowing messages to be sent or read, so after all nodes have
initiated the protocol nothing else is allowed to happen by our
specification, and it is impossible to obtain a valid trace. Recall
that traces are infinite sequences of states. A simple way to solve this issue is to add an event
allowing the system to <em>stutter</em>, that is to do nothing (keeping the
value of all relations unchanged). Stuttering can also be understood as
an event specifying something else that is occurring on the environment
outside the scope of our specification, and in general it is a good
idea to add such stuttering events. In this case, a
predicate to specify a stuttering event can be specified as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">stutter</span> <span class="o">{</span>
  <span class="c1">// no node acts</span>

  <span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">outbox</span>
  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span>
  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To allow this event we need to change the above fact that restricts
the possible behaviors.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fact</span> <span class="nf">stutter_or_initiate</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span><span class="n">stutter</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-16">Running command <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example3</span></code> returns a trace where nothing happens
in our system, something that is now allowed. If we press
<span class="guilabel">New Fork</span> we might get a trace such as the previously
depicted, where <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node2</span></code> initiates the protocol and then nothing
else happens. If we move to the next state by pressing <span class="guilabel">→</span>,
and fork again with <span class="guilabel">New Fork</span>, we might get the following
trace where <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node0</span></code> initiates the protocol after <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node2</span></code>.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_9/leaderelection.als#L66-L77"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance92.png" style="width: 600px;" />
</a>
<p>By exploring a bit more the possible traces we can get some confidence
that event <em>initiate</em> is well specified.</p>
<p>Let us now specify the <em>send</em> event. In this event we could have as parameters the node
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> from where the message will be sent and the message
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> that will be sent (an identifier). The guard of this event
should require <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> to be in the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>. The
effect will be to remove <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> from the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> of
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>, and add it to the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> of the next node <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code>. All
other inboxes and outboxes should keep their value, as well as the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> set. The specification of this event would be the following.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">send</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is sent from node n to its successor</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>                              <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">-</span> <span class="n">i</span>                   <span class="c1">// effect on n.outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>    <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">i</span>           <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span> <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>                         <span class="c1">// frame condition on Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-17">For event <em>process</em> message, again we will have as parameters the node
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> and the message <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> to be
read and processed. The guard should require that <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> is in the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>. The effect on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> is obvious:
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> should be removed from the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> and
all other inboxes should keep their value. The effect on the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> depends on whether <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> is
greater than <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">id</span></code>: if so, <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> should be added to the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code>, to be later propagated along the ring; if not, it
should not be propagated, meaning the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> will
keep its value.  To write such conditional outcome we could use the
logical operator <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">implies</span></code> together with an <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">else</span></code>:
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">C</span> <span class="ow">implies</span> <span class="n">A</span> <span class="k">else</span> <span class="n">B</span></code> is the same as <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="o">(</span><span class="n">C</span> <span class="ow">and</span> <span class="n">A</span><span class="o">)</span> <span class="ow">or</span> <span class="o">(</span><span class="ow">not</span> <span class="n">C</span>
<span class="ow">and</span> <span class="n">B</span><span class="o">)</span></code>, but the former is easier to understand.  The event has no
effect on the outboxes of other nodes, which should all keep their
value. The same conditional outcome applies to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>: if the
received <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> is equal to the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>’s own identifier, then
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> should be included in <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>; otherwise <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>
keeps its value. The full specification of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">process</span></code> is as
follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                 <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                       <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>        <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">gt</span><span class="o">[</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="o">]</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">i</span> <span class="c1">// effect on n.outbox</span>
              <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>      <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">implies</span> <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span> <span class="o">+</span> <span class="n">n</span>      <span class="c1">// effect on Elected</span>
           <span class="k">else</span>    <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>We should now add these two events to the fact that constraints the
valid behaviors of our system. We will also factorize all node events into a separate predicate, to later simplify the specification of fairness conditions.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">node_acts</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="n">send</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">])</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="n">process</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">])</span>

<span class="o">}</span>

<span class="k">fact</span> <span class="nf">events</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span><span class="n">stutter</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">node_acts</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-18">Before proceeding to the verification of the expected properties of
the protocol, we should play around with the different instance
exploration buttons to explore different execution scenarios and
validate the specification of our events. An alternative would be to
ask for specific scenarios directly in a <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">run</span></code> command. For
example, we could change command <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example</span></code> to ask directly for a
scenario where some node will be elected. To do so we need to use the
temporal operator <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">eventually</span></code>, which checks if a formula is
valid at some point in the future (including the present state). Our
command would look as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">eventually_elected</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="k">some</span> <span class="n">Elected</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Id</span>
</pre></div>
</div>
<p>Running this command will return a trace with 8 states where the highest
identifier is passed around until the respective node gets elected. This is the
shortest trace where a leader can be elected in a ring with 3 nodes,
corresponding to one initiate event followed by 3 interleaved send and process
message events. With the bounded model-checking engine that is used by default,
the Analyzer guarantees that the shortest traces that satisfy (or refute) a
property are returned first. The first transition of this trace is the
following, where the node with the highest identifier (<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Id2</span></code>) initiates
the protocol.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_10_11/leaderelection.als#L106-L118"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance101.png" style="width: 600px;" />
</a>
<p>In the last transition, that can be focused by pressing <span class="guilabel">→</span> 6 times or
by directly clicking the state numbered 6 in the trace depiction, this node
reads back its own identifier that was passed around in the ring and elects
himself as leader.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_10_11/leaderelection.als#L106-L118"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance115.png" style="width: 600px;" />
</a>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-file-badge" viewBox="0 0 16 16" aria-hidden="true"><path d="M2.75 1.5a.25.25 0 0 0-.25.25v11.5c0 .138.112.25.25.25h3.5a.75.75 0 0 1 0 1.5h-3.5A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8a1.75 1.75 0 0 1 1.508.862.75.75 0 1 1-1.289.768.25.25 0 0 0-.219-.13h-8Z"></path><path d="M8 7a3.999 3.999 0 0 1 7.605-1.733 4 4 0 0 1-1.115 4.863l.995 4.973a.75.75 0 0 1-.991.852l-2.409-.876a.248.248 0 0 0-.17 0l-2.409.876a.75.75 0 0 1-.991-.852l.994-4.973A3.994 3.994 0 0 1 8 7Zm4-2.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm0 6.5c-.373 0-.745-.051-1.104-.154l-.649 3.243 1.155-.42c.386-.14.81-.14 1.196 0l1.155.42-.649-3.243A4.004 4.004 0 0 1 12 11Z"></path></svg> Alloy model</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Full model for the section</div>
<p class="sd-card-text">Download and explore the files relevant for the model at this point of the book.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference external" href="https://github.com/practicalalloy/models/tree/main/protocol-design/specifying-the-protocol-dynamics"><span>https://github.com/practicalalloy/models/tree/main/protocol-design/specifying-the-protocol-dynamics</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Encoding scenarios</div>
<p class="sd-card-text">Learn how to specify richer <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">run</span></code> commands to search for specific scenarios, where a particular sequence of events occurred.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../behavioral-topics/topics/scenarios/index.html#scenarios"><span class="std std-ref">Encoding trace scenarios</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Event depiction</div>
<p class="sd-card-text">Learn a simple Alloy idiom that can be used to depict which events occurred in each transition of a trace.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../behavioral-topics/topics/event-depiction/index.html#event-depiction"><span class="std std-ref">An idiom for event depiction</span></a></div>
</div>
</section>
<section id="verifying-the-expected-properties">
<h2>Verifying the expected properties<a class="headerlink" href="#verifying-the-expected-properties" title="Link to this heading">¶</a></h2>
<p>The key property of our protocol is that exactly one node
will become leader. We can break this property into three simpler ones:</p>
<ul class="simple">
<li><p>there will never be more than one leader;</p></li>
<li><p>every leader remains leader;</p></li>
<li><p>eventually there will be at least one leader.</p></li>
</ul>
<p id="index-19">These properties are of very different nature: the first two are a
<em>safety</em> properties, forbidding some (undesired) behavior of the system,
while the latter is a <em>liveness</em> property, forcing some (desirable)
behavior of the system. The analysis of safety properties is usually
simpler than the analysis of liveness properties. To find a
counter-example for a safety property it suffices to search for a
finite sequence of states that leads to a (bad) state (in the case
of the first property, one state where there are two or more leaders), and it is irrelevant what
happens afterwards, as any continuation of this finite sequence will
still be a counter-example. On the other hand, to find a
counter-example for a liveness property it is necessary to search for
a complete infinite trace where the expected behavior definitely never
happened (in the case of the last property, one trace where a leader is never elected). Moreover, it will
be necessary to impose additional <em>fairness</em> conditions when verifying
liveness properties, in particular to forbid unreasonable counter-examples
where at some point the system stutters forever and the nodes never execute an enabled event.</p>
<p id="index-20">Let us start by verifying the first (safety) property. Recall that
properties that are expected to hold can be written in named
assertions (declared with keyword <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">assert</span></code>) and then verified
with <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">check</span></code> commands. This safety property is a very simple
example of an <em>invariant</em>, a property that requires something to be
be true in all states of all possible traces. In Alloy, invariants can
be specified using the temporal operator <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">always</span></code>. In each state, to check that
there is at most one leader in set <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> we could use
the keyword <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">lone</span></code>. This invariant could thus
be specified as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">at_most_one_leader</span> <span class="o">{</span>
  <span class="ow">always</span> <span class="o">(</span><span class="k">lone</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To check this assertion we could define the following command.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span>
</pre></div>
</div>
<p id="index-21">This protocol is known to be correct, so, as expected, running this
command returns no counter-example. Recall that the default scope on
top-level signatures is 3, so this command actually verifies that the property holds for all rings with up to three
nodes. This Alloy ability of model checking a property at once for all possible configurations of a system is not possible in some competing model checkers, where we are forced to specify the specific configuration on which we want to verify a protocol. That is rather cumbersome, since with a reasonable scope there can be many different configurations and its difficult to even enumerate them manually. Also, we could easily miss a bug in a specific configuration.</p>
<p id="index-22">As mentioned in chapter <a class="reference internal" href="../behavioral-modeling/index.html#behavioral-modeling"><span class="std std-ref">Behavioral modeling</span></a>, by default, verification of temporal properties in Alloy is
done with a technique known as <em>bounded model checking</em>, meaning that
the search for counter-examples will only consider a given maximum
number of different transitions before the system starts
exhibiting a repeated behavior. By default this maximum number
is 10. To increase our confidence in the result of the analysis we
could, for example, check this property for all rings with up to 4
nodes and consider up to 20 different transitions (or steps). To do so
we could change the scope of the command as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="k">for</span> <span class="mi">4</span> <span class="k">but</span> <span class="mi">20</span> <span class="k">steps</span>
</pre></div>
</div>
<p>This commands sets the default scope on signatures to 4 but also
changes the scope on transitions to 20 using keyword
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">steps</span></code>. Again, as expected, no counter-example is returned, but
the analysis now takes considerably longer, as there are many more
network configurations and states to explore.</p>
<p id="index-23">It is also possible to check a temporal property with <em>complete model
checking</em> if a compatible solver is selected. This will consider an arbitrary number of
transitions, but still with the signatures bounded by a maximum
scope. To do so, a special scope on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">steps</span></code> is needed
to trigger unbounded temporal analysis.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="k">for</span> <span class="mi">4</span> <span class="k">but</span> <span class="mi">1</span><span class="o">..</span> <span class="k">steps</span>
</pre></div>
</div>
<p>The second expected property is another example of a safety property, this time requiring a nested <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">always</span></code> operator to be specified.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">leader_stays_leader</span> <span class="o">{</span>
  <span class="ow">always</span> <span class="o">(</span><span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Elected</span> <span class="o">|</span> <span class="ow">always</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">check</span> <span class="n">leader_stays_leader</span>
</pre></div>
</div>
<p>Again this assertion is true, as expected. Note that the universal quantification on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> could not be moved outside the first <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">always</span></code>, because <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> is a mutable subset signature, and if used outside any temporal connective it will be evaluated in the initial state, where it is empty. Of course, that is not what we want. Here we check that <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> never decreases in content, that is, at every state any node that it contains will remain in <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> for ever. Combined with <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">at_most_one_leader</span></code> this ensures that there can never exist two different leaders.</p>
<p>The third expected property is a very simple example of a liveness
requirement, namely one that requires something to hold at least in
one state of every trace. In this case we want to make sure that at least one node will be elected. Simple liveness properties such as this one can many times be specified directly
with the temporal connective <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">eventually</span></code>. Inside this temporal
connective, again a very simple cardinality check on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>
suffices, this time with keyword <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">some</span></code>.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">at_least_one_leader</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="o">(</span><span class="k">some</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The following command can be used to check this property with bounded model
checking and the default scopes.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_least_one_leader</span>
</pre></div>
</div>
<p>We recommend that you start by
verifying specifications with bounded model checking, because for small scopes on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">steps</span></code> it is
usually much faster than the unbounded counterpart, and most
counter-examples tend to require only a handful of transitions. Once
you have a design where no counter-example is returned with bounded
model checking, you can increase your confidence on the analysis by using
unbounded model checking. As hinted above, running this command immediately returns a
counter-example where the system stutters forever, and obviously no
leader is elected. This counter-example can be replicated in trivial configurations, for example the following with a single node.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_12/leaderelection.als#L123-L134"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance121.png" style="width: 600px;" />
</a>
<p id="index-24">This behavior is currently allowed because we added a stutter event that
captures events external to our system. At the moment this event can
occur indefinitely, which is a bit unrealistic or <em>unfair</em> to the
system under analysis: in particular, if at some point one node is
continuously ready to execute one of its events (the node is continuously
<em>enabled</em>), then it should eventually do something. For example, in our
protocol, a trace where at some point a message is in the inbox of a
node but is never processed is unfair to that node.</p>
<p>To specify  fairness properties that exclude such unreasonable executions, we first need to understand two
well-known combinations of the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">always</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">eventually</span></code>
temporal operators:</p>
<ul class="simple">
<li><p><code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">eventually</span> <span class="ow">always</span> <span class="n">P</span></code> holds in a system if all traces reach a state where <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">P</span></code> becomes valid indefinitely.</p></li>
<li><p><code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">always</span> <span class="ow">eventually</span> <span class="n">P</span></code> holds in a system if in every state of every trace <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">P</span></code> is later valid, which means that <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">P</span></code> is true infinitely often.</p></li>
</ul>
<p>To specify that a node is at some point continuously enabled we can use the
first combination. Most of the times the enabled condition for a node is exactly
the same as the disjunction of the guards of its events. In our case a node
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> is enabled if it has never initiated or has some message in the inbox
or in the outbox. To specify that a continuously enabled event eventually occurs
(after the point it becomes enabled) the second combination of operators
presented above can be used. Note that a continuously enabled event would still
be (continuously) enabled after the required occurrence of the event, which
means that the event should occur again and again, or infinitely often. So, the
desired fairness condition can be specified as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="ow">historically</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
<span class="o">}</span>
<span class="k">pred</span> <span class="nf">process_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">some</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>
<span class="k">pred</span> <span class="nf">send_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">some</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
<span class="o">}</span>
<span class="k">pred</span> <span class="nf">node_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">initiate_enabled</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="n">process_enabled</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">])</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Id</span> <span class="o">|</span> <span class="n">send_enabled</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">])</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">fairness</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="ow">eventually</span> <span class="ow">always</span> <span class="n">node_enabled</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
    <span class="ow">implies</span>
    <span class="ow">always</span> <span class="ow">eventually</span> <span class="n">node_acts</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p id="index-25">Here we specified separately the enabled conditions for each of the events.
Technically, this fairness condition is known as <em>weak fairness</em>, as
a node is only required to act if is continuously enabled. Often
this suffices to verify most liveness properties. However, sometimes
we may need <em>strong fairness</em> constraints, requiring that some event
occurs when it becomes recurrently enabled (infinitely often, but
not necessarily continuously).</p>
<p>If we change the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">at_least_one_leader</span></code> assertion to assume
the above fairness condition, no counter-example will be returned even with increased
scopes, as expected.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">at_least_one_leader_fair</span> <span class="o">{</span>
  <span class="n">fairness</span> <span class="ow">implies</span> <span class="ow">eventually</span> <span class="o">(</span><span class="k">some</span> <span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">check</span> <span class="n">at_least_one_leader_fair</span>
</pre></div>
</div>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-file-badge" viewBox="0 0 16 16" aria-hidden="true"><path d="M2.75 1.5a.25.25 0 0 0-.25.25v11.5c0 .138.112.25.25.25h3.5a.75.75 0 0 1 0 1.5h-3.5A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8a1.75 1.75 0 0 1 1.508.862.75.75 0 1 1-1.289.768.25.25 0 0 0-.219-.13h-8Z"></path><path d="M8 7a3.999 3.999 0 0 1 7.605-1.733 4 4 0 0 1-1.115 4.863l.995 4.973a.75.75 0 0 1-.991.852l-2.409-.876a.248.248 0 0 0-.17 0l-2.409.876a.75.75 0 0 1-.991-.852l.994-4.973A3.994 3.994 0 0 1 8 7Zm4-2.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm0 6.5c-.373 0-.745-.051-1.104-.154l-.649 3.243 1.155-.42c.386-.14.81-.14 1.196 0l1.155.42-.649-3.243A4.004 4.004 0 0 1 12 11Z"></path></svg> Alloy model</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Full model for the section</div>
<p class="sd-card-text">Download and explore the files relevant for the model at this point of the book.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference external" href="https://github.com/practicalalloy/models/tree/main/protocol-design/verifying-the-expected-properties"><span>https://github.com/practicalalloy/models/tree/main/protocol-design/verifying-the-expected-properties</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Fairness and Liveness</div>
<p class="sd-card-text">Learn how to specify different fairness conditions and the impact they have on the analysis.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../behavioral-topics/topics/fairness/index.html#fairness"><span class="std std-ref">tocdepth</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
A temporal logic primer</div>
<p class="sd-card-text">Read about the full syntax and semantics of the temporal logic supported in Alloy.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../behavioral-topics/topics/temporal-logic/index.html#temporal-logic"><span class="std std-ref">tocdepth</span></a></div>
</div>
</section>
<section id="making-the-specification-more-abstract">
<h2>Making the specification more abstract<a class="headerlink" href="#making-the-specification-more-abstract" title="Link to this heading">¶</a></h2>
<p>There are several ways in which we can make our specification of this protocol more abstract, and potentially speed up its analysis. For example, we actually do not need to model the identifiers explicitly: we can use each node atom name as its own identifier. To model this, we could impose the total order on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code> itself, and get rid of signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Id</span></code> and field <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">id</span></code>. Also, messages are now the node atoms, and the declaration of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> should change accordingly. However, imposing a total order with <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">util</span><span class="o">/</span><span class="n">ordering</span></code> will make the scope on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code> exact, which means that for a given scope we would only verify all configurations with that exact number of nodes. This is undesirable, because we could easily miss bugs for smaller configurations. As such, instead of using <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">util</span><span class="o">/</span><span class="n">ordering</span></code> we will directly impose a total order on the nodes, by explicitly adding a <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">next</span></code> relation, the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">first</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">last</span></code> nodes, and the corresponding fact.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var </span><span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var </span><span class="n">outbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span>
<span class="o">}</span>
<span class="k">one</span> <span class="kd">sig</span> <span class="nc">first</span><span class="p">,</span> <span class="nc">last</span> <span class="k">in</span> <span class="nc">Node</span> <span class="o">{}</span>

<span class="k">fact</span> <span class="nf">ordering</span> <span class="o">{</span>
  <span class="k">no</span> <span class="n">next</span><span class="o">.</span><span class="n">first</span> <span class="ow">and</span> <span class="k">no</span> <span class="n">last</span><span class="o">.</span><span class="n">next</span>
  <span class="n">Node</span><span class="o">-</span><span class="n">first</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.^</span><span class="n">next</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Actually, in our first model with a separate <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Id</span></code> signature and using <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">util</span><span class="o">/</span><span class="n">ordering</span></code> we were verifying some redundant configurations that were symmetric for this protocol. For example, with the default scope of 3, the scope of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Id</span></code> was exactly 3, meaning that even if we had less than 3 nodes, there would still exist 3 identifiers. This means that, for example, for a network of 2 nodes we were analyzing three configurations: one where the identifiers were consecutive starting in the first identifier, one where the identifiers were consecutive starting in the second identifier, and one where the identifiers differed in two units. For this protocol, where we just need to check which identifier is greater, all these configurations are equivalent, and thus it would be unnecessary to check them all. In this new version without explicit identifiers, we no longer have this issue, and for a scope of 3 only 4 truly different configurations will be analyzed: one network with one node, one with two nodes, and two networks with three nodes, one where <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">next</span></code> is in the same order of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">succ</span></code> and one where it is in reverse order.</p>
<p>Of course, after removing <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Id</span></code> we have to slightly change the specification of our event predicates and the assertions. For example, event <em>process</em> can now be specified as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                   <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                         <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>          <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">i</span>  <span class="c1">// effect on n.outbox</span>
               <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>        <span class="c1">// effect on the outboxes of other nodes</span>

  <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span> <span class="o">+</span> <span class="n">n</span>           <span class="c1">// effect on Elected</span>
        <span class="k">else</span>    <span class="n">Elected</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">Elected</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that since we now don’t have the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">gt</span></code> predicate available we directly compared nodes using the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">next</span></code> relation.</p>
<p>The <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">eventually_elected</span></code> command now only needs to specify a scope for <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code>.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">eventually_elected</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="k">some</span> <span class="n">Elected</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span>
</pre></div>
</div>
<p>Running this command yields the following instance (with the theme already customized), and it is now more clear if the ring follows the increasing order of the identifiers (as happens here), or the other way around. Notice that without using <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">util</span><span class="o">/</span><span class="n">ordering</span></code>, the node identifiers are no longer representative of the total order (in the trace below, <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node2</span></code> is the first element of the total order, and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node1</span></code> the last).</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_13/leaderelection.als#L103-L113"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance131.png" style="width: 600px;" />
</a>
<p>Another signature we can remove is <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>, since actually we can infer which node has been elected by looking at what happened in the past: if at some point in the past a node had its identifier in the inbox and processed it, then it necessarily became a leader. Instead of declaring a subset signature we can define <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> as a derived set of nodes using a function without parameters.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here, the set of elected nodes at each state is defined by comprehension. Note
the usage of the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">once</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">before</span></code> past operators to check if
the desired transition happened in the past. We can now simplify the
specification of all three events, removing the effects on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>. For
example, event <em>process</em> can now be specified as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                     <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                           <span class="c1">// effect on n.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>            <span class="c1">// effect on the inboxes of other nodes</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span> <span class="o">+</span> <span class="n">i</span>    <span class="c1">// effect on n.outbox</span>
               <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">outbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">outbox</span>          <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Another abstraction could be to remove the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">outbox</span></code> and incorporate the sending of a message in the <em>initiate</em> and <em>process</em> events. This is a reasonable simplification in this protocol, since each node only communicates with the successor node, and out of order message delivery is already being modeled by having the inboxes contain sets of messages. The declaration of signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code> becomes the following.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var </span><span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The specification of event <em>initiate</em> should be changed to directly add the node identifier to the inbox of the successor node.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>          <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">n</span>            <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>  <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Finally, the specification of <em>process</em> should also be changed accordingly.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                          <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                                <span class="c1">// effect on n.inbox</span>
  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">i</span> <span class="c1">// effect on n.succ.inbox</span>
               <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>        <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>After removing event <em>send</em> from predicate <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">node_acts</span></code>, we can run the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">eventually_elected</span></code> command and see that it is now possible
to elect a leader in a ring with three nodes with almost half the transitions.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_14/leaderelection.als#L77-L86"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance141.png" style="width: 600px;" />
</a>
<p>With the same scope on the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">steps</span></code> we can now check much longer behaviors
with roughly the same efficiency. If we check our three assertions they are all
still valid, as expected.</p>
<p>However, this specification is actually not correct! If we run the following
command to get an example of electing a leader in a ring with one node, we will
get no instances.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">eventually_elected_1node</span> <span class="o">{</span>
  <span class="ow">eventually</span> <span class="k">some</span> <span class="n">Elected</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">1</span> <span class="n">Node</span>
</pre></div>
</div>
<p>The problem is in the specification of the effect of <em>process</em> on
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span></code>. If the ring has a single node, both <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> and
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code> are the same node, and the two conditions specifying the effect
on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span></code> and on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">inbox</span></code> contradict themselves, so the
<em>process</em> event cannot actually occur (is not truly enabled) even if its guard
is true in a state. This was the reason why checking the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">at_least_one_leader_fair</span></code> assertion did not produce a counter-example, because
the fairness condition now has the wrong enabledeness condition for this event. It
is very easy to make such subtle mistakes while specifying, and introduce
inconsistencies in our model, and to avoid them we should always exhaustively validate our
specification before checking our assertions. This is specially true for liveness properties. Ideally, we should have different
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">run</span></code> commands to check the consistency of different scenarios, for
instance asking for examples where leaders are elected in rings of different
sizes. To fix the specification of <em>process</em> we could require the frame
condition on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span></code> to only apply when <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code> is not <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>
itself.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                          <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">-</span> <span class="n">i</span>                                <span class="c1">// effect on n.inbox</span>
  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span> <span class="o">+</span> <span class="n">i</span> <span class="c1">// effect on n.succ.inbox</span>
               <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>        <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If we ask for a trace where a leader is elected in a ring with one node, we now get the expected outcome after two events.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_15_16/leaderelection.als#L81-L90"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance151.png" style="width: 600px;" />
</a>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/e9d9cb2eff0bb71f51de53791e5cb2a1280bafe9/protocol-design/instance_15_16/leaderelection.als#L81-L90"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance161.png" style="width: 600px;" />
</a>
<p>So far we have specified the effects of events in a <em>point-wise</em> style, stating the effect on different projections of the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> separately. Using a <em>point-free</em> style, where we specify the effect on all inboxes at once, can many times considerably simplify the specification. Consider for example the point-free version of the <em>initiate</em> event.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// guard</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">n</span>           <span class="c1">// effect on inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Now we just specify in a single constraint that the binary relation <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> should have a new tuple in the next state, namely one where <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> was added to the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code>.</p>
<p>For <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">process</span></code> specifying the effect on the all <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> in a single constraint is a bit more challenging, but could be done as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>                                    <span class="c1">// guard</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span><span class="o">)</span>   <span class="c1">// effect on inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In the next state, binary relation <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> should have one less tuple, corresponding to deleting <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> from the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>, and, if <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span></code> one more tuple, corresponding to adding <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> to the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code>. This last conditional addition was specified by always adding tuple <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span><span class="o">)</span></code> to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code>: note that expression <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span></code> is equal to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span></code> if <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span></code> or <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="kc">none</span></code> otherwise, hence in the latter case no tuple will be added since the Cartesian product with an empty set is also an empty binary relation.</p>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-file-badge" viewBox="0 0 16 16" aria-hidden="true"><path d="M2.75 1.5a.25.25 0 0 0-.25.25v11.5c0 .138.112.25.25.25h3.5a.75.75 0 0 1 0 1.5h-3.5A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8a1.75 1.75 0 0 1 1.508.862.75.75 0 1 1-1.289.768.25.25 0 0 0-.219-.13h-8Z"></path><path d="M8 7a3.999 3.999 0 0 1 7.605-1.733 4 4 0 0 1-1.115 4.863l.995 4.973a.75.75 0 0 1-.991.852l-2.409-.876a.248.248 0 0 0-.17 0l-2.409.876a.75.75 0 0 1-.991-.852l.994-4.973A3.994 3.994 0 0 1 8 7Zm4-2.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm0 6.5c-.373 0-.745-.051-1.104-.154l-.649 3.243 1.155-.42c.386-.14.81-.14 1.196 0l1.155.42-.649-3.243A4.004 4.004 0 0 1 12 11Z"></path></svg> Alloy model</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Full model for the section</div>
<p class="sd-card-text">Download and explore the files relevant for the model at this point of the book.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference external" href="https://github.com/practicalalloy/models/tree/main/protocol-design/making-the-specification-more-abstract"><span>https://github.com/practicalalloy/models/tree/main/protocol-design/making-the-specification-more-abstract</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Pointwise effects</div>
<p class="sd-card-text">Learn about the different ways to specify effects and frame conditions of events. Here we used the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">point</span><span class="o">-</span><span class="n">free</span></code> style to simplify the specifications.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../behavioral-topics/topics/pointwise-effects/index.html#pointwise-effects"><span class="std std-ref">Pointwise effects</span></a></div>
</div>
</section>
<section id="explicit-messages-as-signatures">
<h2>Explicit messages as signatures<a class="headerlink" href="#explicit-messages-as-signatures" title="Link to this heading">¶</a></h2>
<p>Up until now, we only specified the first phase of the leader election
protocol. In a second phase, once a node identifies itself as the leader, it
should propagate that information to all the other nodes to make sure that
every node is aware of the elected leader. This second phase can begin while
there are still messages from the first phase being exchanged. A message informing about the newly elected leader contains the payload exchanged in the first phase: a node identifier, in this case of the elected leader instead of candidate. Thus, we can no longer abstract messages by just exchanging
identifiers between nodes, and must introduce a richer message type into our model to distinguish between the messages exchanged in the two phases of the protocol.
In a
programming language we would probably encode messages using a <em>record</em>, or
<em>struct</em> type. In Alloy such records can to be encoded with signatures, but that causes some issues that will be discussed in this section.</p>
<p>We can easily extend our model to support different types of messages by introducing an abstract
static signature to represent them, and then extend it by the more specific
message types. Signature fields would represent the payload or data fields of the messages.
In our leader election protocol, we have two message types that happen to
contain the same payload – a node identifier – so we can define that
field at the top-level signature, which will be inherited by the specific
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">CandidateMsg</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">ElectedMsg</span></code>. The payload is mandatory, so it is
assigned multiplicity <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">one</span></code>.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Message</span> <span class="o">{</span>
  <span class="n">payload</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span>
<span class="o">}</span>
<span class="kd">sig</span> <span class="nc">CandidateMsg</span><span class="p">,</span> <span class="nc">ElectedMsg</span> <span class="k">extends</span> <span class="nc">Message</span> <span class="o">{}</span>
</pre></div>
</div>
<p>Then we need to adapt the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> declaration to contain the new messages instead of just node identifiers.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var </span><span class="n">inbox</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Message</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Next, we must adapt the event predicates to consider the new message types. Some of these
events (such as when a node initiates, or elects itself the leader) are expected
to ‘create’ new messages. This will expose a main difference between having true record-like data
structures and Alloy static signatures: with the latter, messages will in fact never
really be created, since all possible messages that can be sent in an execution already belong to signature <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> in the initial state. The ‘creation’ of a new message will be specified by an existential quantification that searches for an atom inside <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> with the required type and content. Predicate <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">initiate</span></code>, for instance, could be adapted in the
following way.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="k">no</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>          <span class="c1">// guard</span>

  <span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">|</span> <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">m</span>   <span class="c1">// effect on inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The first difference to our previous specification is in the guard: rather than testing whether its own
identifier has ever been in the inbox of its successor, a node can now only initiate if
a candidate message with its identifier was never in that inbox. Note that for a node identifier <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>,
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">payload</span><span class="o">.</span><span class="n">n</span></code> retrieves all messages with that identifier, which intersected with
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">CandidateMsg</span></code> gives all candidate messages for node <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> (in the current model,
there may be multiple <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">CandidateMsg</span></code> atoms with the same payload). The second
difference, as we already mentioned, is the use of an existential quantification in the effect to pick a message of the
appropriate type and content to be added it to the successor’s inbox.</p>
<p>Rather than having an identifier as a parameter, the <em>process</em> event should now
consider a message. To ease the specification, we split the <em>process</em> event into
two different events specified in different predicates: processing a <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">CandidateMsg</span></code> message or processing an
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">ElectedMsg</span></code> message. Predicate <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">processCandidate</span></code> becomes slightly more
complicated, since there are now three possible effects on the successor’s
inbox: as previously, a node receiving a candidate message may discard it (if the identifier in
the message is smaller than its own), or propagate it (if the identifier in the message is larger than its own). But now, when a node identifies itself as the leader (the identifier in the message is the same as its own), it must also send a new elected message informing other nodes that it become the leader. One possibility to specify this event is as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processCandidate</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// candidate message m is read and processed by node n</span>

  <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// guard</span>

  <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span> <span class="ow">implies</span>           <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">m</span>  <span class="c1">// effect on inbox</span>
  <span class="k">else</span> <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="ow">in</span> <span class="o">^</span><span class="n">next</span><span class="o">.</span><span class="n">n</span> <span class="ow">implies</span>      <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">m</span>
  <span class="k">else</span> <span class="k">some</span> <span class="n">e</span> <span class="p">:</span> <span class="n">ElectedMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">|</span> <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">e</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Due to the need to send a different type of message in the last case, it is now more difficult to specify the effect in a single case, so we keep the three cases separate.</p>
<p>Predicate <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">processElected</span></code> is quite simple, just propagating the elected messages
unless it’s the elected leader receiving the message again, in which case it is discarded.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processElected</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// elected message m is read and processed by node n</span>

  <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// guard</span>

  <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">m</span>  <span class="c1">// effect on inbox</span>
                 <span class="k">else</span>    <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">m</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Concerning <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code>, we would now to consider a more interesting version, where we register for each node which other node it considers the leader, if any. As such, we will change <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> to return not the set of elected nodes, but a binary relation that for each node returns the leader it currently knows. A node gets to know who is the leader when it processes an elected message, so the set of leaders for each node is the payload of all previously processed messages of this type. We can define this relation by comprehension, using a <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">let</span></code>-expression to denote the set of elected messages in a node inbox.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-&gt;</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span>
    <span class="k">let</span> <span class="n">inbox_elected</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">ElectedMsg</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="o">|</span>
      <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="k">some</span> <span class="n">inbox_elected</span> <span class="ow">and</span> <span class="k">no</span> <span class="n">inbox_elected</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Lastly, we just have to update the fact that specifies what are the valid executions of the protocol.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">node_acts</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">|</span> <span class="n">processCandidate</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">])</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span> <span class="o">|</span> <span class="n">processElected</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">])</span>
<span class="o">}</span>

<span class="k">fact</span> <span class="nf">events</span> <span class="o">{</span>
  <span class="c1">// possible events</span>
  <span class="ow">always</span> <span class="o">(</span><span class="n">stutter</span> <span class="ow">or</span> <span class="k">some</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">node_acts</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Let us validate the new version of our protocol using the functionalities
provided by the Analyzer. Let us run our empty <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">run</span></code> command <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">example</span></code> just to
explore some possible traces. The first trace returned is one where there is a
single node and the system stutters forever (recall that bounded model checking
guarantees minimal trace prefix length). By hitting <span class="guilabel">New Fork</span> we
should be able to observe a different event, namely an <em>initiate</em> event.
However, depending on the selected solver, we may get the following message.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/40da9924bc7abef72c2bafb6875e9f779230d48a/protocol-design/instance_17_18/leaderelection.als#L96-L105"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/validation1.png" style="width: 600px;" />
</a>
<p id="index-26">Let’s try to use the evaluator to debug the trace. Recall that the evaluator for
traces supports any formula and expression, and that this evaluation is always
performed on the focused state (the one at the left-hand side). We can start by
confirming that the system is simply stuttering by calling <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">stutter</span></code> at the
current state (in this case, this is still the initial one since we did not navigate in the
trace). We can also ask if <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">stutter</span></code> is happening <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">after</span></code> or even <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">always</span></code>. For all theses cases the
evaluator will answer <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">true</span></code> as expected. We can then ask the evaluator whether
there is <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">some</span></code> node for which the guard of the <em>initiate</em> predicate holds (a
formula with the past operator <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="ow">historically</span></code>), or use comprehension to get all
nodes for which that guard holds. The evaluator will show us that it holds for
the existing node. So this must be a case where the guard is not necessarily
the same as the enabled condition of the event. The problem is in the existential quantifier  searching for the new candidate message: this cannot be satisfied because there is no available <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">CandidateMsg</span></code> message in the configuration
of this trace that can be added to the successor’s inbox.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/40da9924bc7abef72c2bafb6875e9f779230d48a/protocol-design/instance_17_18/leaderelection.als#L96-L105"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/validation2.png" style="width: 600px;" />
</a>
<p>This issue is actually evident if we inspect the available messages in the
visualizer, as there are only <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">ElectedMsg</span></code> messages in the configuration. So we
can hit <span class="guilabel">New Config</span> until a <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">CandidateMsg</span></code> is available (after
closing the evaluator). This should happen after a few iterations. Then, we can
ask again for <span class="guilabel">New Fork</span>, and this time a node will effectively
initiate.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/40da9924bc7abef72c2bafb6875e9f779230d48a/protocol-design/instance_17_18/leaderelection.als#L107-L116"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance181.png" style="width: 600px;" />
</a>
<p>This means that to simulate a specific scenario we must first think about which messages will be necessary and hit <span class="guilabel">New Config</span> until those messages are in scope at the initial state. Of course, this does not scale to more complex scenarios.</p>
<p>Another problem occurs when we want to inspect a different network
configuration (recall that with up to 3 nodes, there are only 4 distinct
configurations). This should be easy to achieve by using <span class="guilabel">New Config</span>.
Unfortunately, you’ll notice that the network configuration most likely stays the same,
and only the set of available messages keeps changing. This is due to the fact that, as we’ve seen, the available
messages are also part of the configuration because <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> is an immutable signature.
With one of the available solvers we actually
needed to hit <span class="guilabel">New Config</span> 10 times before seeing a different ring
network, and dozens of times to inspect the 4 alternatives, as the Analyzer will
just iterate over different sets of possible messages.</p>
<a class="reference internal image-reference" href="../../_images/validation3.png"><img alt="../../_images/validation3.png" class="align-center" src="../../_images/validation3.png" style="width: 800px;" />
</a>
<a class="reference internal image-reference" href="../../_images/validation4.png"><img alt="../../_images/validation4.png" class="align-center" src="../../_images/validation4.png" style="width: 800px;" />
</a>
<a class="reference internal image-reference" href="../../_images/validation5.png"><img alt="../../_images/validation5.png" class="align-center" src="../../_images/validation5.png" style="width: 800px;" />
</a>
<p id="index-27">One possible solution to circumvent these issues if we have explicit messages is
to enforce a so-called <em>generator axiom</em>. These are constraints that force every possible
combination of field values of a signature to exist <em>in every instance</em>. In our
leader election model, we would want to force the existence of messages with all
possible types and values, which could be specified as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">generator</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span>   <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">n</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In order for models with the generator axiom to be consistent, we must set the
scope to allow every possible  message. In our model, we can have one
message of each type for each available node, so the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> scope should be
twice that of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span></code>. Notice that we define the generator axiom as a predicate,
rather than a fact: enforcing all possible messages to exist is helpful when
exploring scenarios, but might slow down too much the verification properties, where enforcing a large scope for messages might possibly encumber the solving process. This is less of a problem for <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">run</span></code> commands that are expected to be satisfiable, which usually finish quickly. So, for the moment, we
call this predicate only in <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">run</span></code> commands used for validation, such as the one
below for ring networks with exactly 3 nodes.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example3_generator</span> <span class="o">{</span>
  <span class="n">generator</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="mi">6</span> <span class="n">Message</span>
</pre></div>
</div>
<p>This command now guarantees the existence of all possible messages, and simulation using <span class="guilabel">New Fork</span> can easily be done as before. And since we have a tight scope of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> there is a unique configuration of messages
available, and hitting <span class="guilabel">New Config</span> will effectively generate a new
network configuration. Unfortunately, this will only work if we know the smallest scope needed for
messages, which is not always easy to identify. Otherwise,
different messages with the same payload will be allowed to appear in the
configuration. That will be the case if we no longer ask for <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">exactly</span></code> 3
nodes in the command above: for ring networks with 2 nodes, 6 messages result in
repetitions of the network configurations, changing only the available messages. To address this, we can also additionally enforce messages to be
unique with the following predicate.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">unique</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">|</span> <span class="n">m1</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">payload</span> <span class="ow">implies</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">m2</span>
  <span class="k">all</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="p">:</span> <span class="n">ElectedMsg</span>   <span class="o">|</span> <span class="n">m1</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">payload</span> <span class="ow">implies</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">m2</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Given this, even if we assign a scope to messages larger than the one needed, a
unique message configuration is guaranteed to be generated, and <span class="guilabel">New Config</span> will necessarily return a different network configuration (a different ring or a different order of node identifiers).</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">example_unique_generator</span> <span class="o">{</span>
  <span class="n">generator</span>
  <span class="n">unique</span>
<span class="o">}</span> <span class="k">for</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="mi">10</span> <span class="n">Message</span>
</pre></div>
</div>
<p>However, by forcing messages to be unique, we are actually restricting the set
of possible behaviors of our protocol, and we must consider the implications of
that decision. The main consequence is that, since inboxes are modeled as sets,
it is now impossible to have two messages with the same content in an inbox
(elements are unique in sets). But this was already the case in the version of
the  model without messages - a node identifier could only appear once in an
inbox - so supporting duplicated messages was actually a deviation from the
original model. Regardless, this is not an issue in this protocol, since each node sends at most one candidate message and one elected
message with its own identifier.</p>
<p>Regardless of the issues with trace iteration, we should always reason carefully about message scopes. For instance, we could try to ask for a scenario where all nodes initialize, and eventually all nodes know who is the leader, with the following invalid command.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">bad_all_initiate</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">eventually</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
  <span class="ow">eventually</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">Elected</span><span class="o">.</span><span class="n">Node</span>
<span class="o">}</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span>
</pre></div>
</div>
<p>The Analyzer will reply that there is no such trace. That’s because the default scope for signatures is 3, and 3 messages are not sufficient to represent this trace (at least 4 are needed). This can also lead to a false sense of safety from <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">check</span></code> commands, since a limited set of messages may reduce the valid traces explored by the Analyzer. To actually see a trace with 3 nodes where eventually a node is elected, we should use the following command, which returns a trace such as the one below. Notice how <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> is now a binary relation. To improve the visualization, we could introduce an auxiliary function for <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span><span class="o">.</span><span class="n">Elected</span></code> to highlight the nodes considered the leader by any node.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">run</span> <span class="n">all_initiate</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">eventually</span> <span class="n">initiate</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
  <span class="ow">eventually</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">Elected</span><span class="o">.</span><span class="n">Node</span>
<span class="o">}</span> <span class="k">for</span> <span class="k">exactly</span> <span class="mi">3</span> <span class="n">Node</span><span class="p">,</span> <span class="k">exactly</span> <span class="mi">6</span> <span class="n">Message</span>
</pre></div>
</div>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/40da9924bc7abef72c2bafb6875e9f779230d48a/protocol-design/instance_19/leaderelection.als#L166-L180"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance191.png" style="width: 600px;" />
</a>
<p>So, before re-running the 3 check commands defined previously for our leader
election protocol, we should extend the scope of available messages. However, we must first adapt the specification of the properties to the new <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> relation.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="nf">at_most_one_leader</span> <span class="o">{</span>
  <span class="ow">always</span> <span class="k">lone</span> <span class="n">Node</span><span class="o">.</span><span class="n">Elected</span>
<span class="o">}</span>
<span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="mi">6</span> <span class="n">Message</span>

<span class="k">assert</span> <span class="nf">leader_stays_leader</span> <span class="o">{</span>
  <span class="ow">always</span> <span class="o">(</span><span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">.</span><span class="n">Elected</span> <span class="o">|</span> <span class="ow">always</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Node</span><span class="o">.</span><span class="n">Elected</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">check</span> <span class="n">leader_stays_leader</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="mi">6</span> <span class="n">Message</span>

<span class="k">assert</span> <span class="nf">at_least_one_leader_fair</span> <span class="o">{</span>
  <span class="n">fairness</span> <span class="ow">implies</span> <span class="ow">eventually</span> <span class="o">(</span><span class="n">Node</span> <span class="o">=</span> <span class="n">Elected</span><span class="o">.</span><span class="n">Node</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">check</span> <span class="n">at_least_one_leader_fair</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="mi">6</span> <span class="n">Message</span>
</pre></div>
</div>
<p>Note that <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span><span class="o">.</span><span class="n">Elected</span></code> is now the set of leaders known to any of the nodes, so the two safety properties are the same as before, but with the previous <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> set replaced by <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span><span class="o">.</span><span class="n">Elected</span></code>. The liveness property specifies that all nodes will eventually know who is the leader, by requiring that eventually the domain of relation <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> contains all nodes.
The two safety properties are satisfied as before. Here is the result of the analysis for the first.</p>
<a class="reference internal image-reference" href="../../_images/log11.png"><img alt="../../_images/log11.png" class="align-center" src="../../_images/log11.png" style="width: 600px;" />
</a>
<p>To verify the liveness property <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">at_least_one_leader</span></code>, we should first update the fairness
condition to consider the new event and the new guards.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="ow">historically</span> <span class="k">no</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>
<span class="k">pred</span> <span class="nf">processCandidate_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Message</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>
<span class="k">pred</span> <span class="nf">processElected_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Message</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">node_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">initiate_enabled</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">CandidateMsg</span> <span class="o">|</span> <span class="n">processCandidate_enabled</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">])</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">m</span> <span class="p">:</span> <span class="n">ElectedMsg</span> <span class="o">|</span> <span class="n">processElected_enabled</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">])</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">fairness</span> <span class="o">{</span>
  <span class="k">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="ow">eventually</span> <span class="ow">always</span> <span class="n">node_enabled</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
    <span class="ow">implies</span>
    <span class="ow">always</span> <span class="ow">eventually</span> <span class="n">node_acts</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>With this fairness condition property <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">at_least_one_leader_fair</span></code> holds.
Note that in the above enabled conditions we did not explicitly checked if it was possible to create a message of the appropriate type to send. For example in <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">initiate_enabled</span></code> we did not include the condition <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">some</span> <span class="n">CandidateMsg</span> <span class="o">&amp;</span> <span class="n">payload</span><span class="o">.</span><span class="n">n</span></code>. The behaviors where that condition is false will be excluded from the analysis by the fairness property, which is precisely the intended. Also, since our scope for <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> is big enough, the configuration where all possible messages exist will also be analyzed, and in that configuration those constraints would be trivially true, and so all the interesting behaviors will still be verified.
Actually, when using explicit messages it might be a good idea to just change the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">generator</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">unique</span></code> predicates to facts, because analysis commands will only have to explore a single message configuration and this might lead to efficiency gains (besides all the advantages in validation). Of course, then we must be very careful to always choose a big enough scope for messages. The only reason to keep them as predicates is if the scope needed to have all possible messages becomes too big: in that case the analysis might be too inefficient, and without the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">generator</span></code> axiom we might still be able to check the property for a smaller number of messages. Of course, then we will have no guarantees that all possible executions for a given number of nodes are explored, but we might still be able to find bugs and have some confidence in the results.</p>
<p>The reader might wonder if instead of having a static <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> signature we could declare it as mutable, and then really create new messages when they are needed. That can be done in Alloy, but, unfortunately, from our experience, that option makes specification more difficult and analyses less efficient, when compared to the static version with the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">generator</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">unique</span></code> assumptions, so we will not discuss it here. And concerning efficiency, there is a much better alternative that we will discuss next, that is to not have explicit messages as signatures.</p>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-file-badge" viewBox="0 0 16 16" aria-hidden="true"><path d="M2.75 1.5a.25.25 0 0 0-.25.25v11.5c0 .138.112.25.25.25h3.5a.75.75 0 0 1 0 1.5h-3.5A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8a1.75 1.75 0 0 1 1.508.862.75.75 0 1 1-1.289.768.25.25 0 0 0-.219-.13h-8Z"></path><path d="M8 7a3.999 3.999 0 0 1 7.605-1.733 4 4 0 0 1-1.115 4.863l.995 4.973a.75.75 0 0 1-.991.852l-2.409-.876a.248.248 0 0 0-.17 0l-2.409.876a.75.75 0 0 1-.991-.852l.994-4.973A3.994 3.994 0 0 1 8 7Zm4-2.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm0 6.5c-.373 0-.745-.051-1.104-.154l-.649 3.243 1.155-.42c.386-.14.81-.14 1.196 0l1.155.42-.649-3.243A4.004 4.004 0 0 1 12 11Z"></path></svg> Alloy model</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Full model for the section</div>
<p class="sd-card-text">Download and explore the files relevant for the model at this point of the book.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference external" href="https://github.com/practicalalloy/models/tree/main/protocol-design/explicit-messages-as-signatures"><span>https://github.com/practicalalloy/models/tree/main/protocol-design/explicit-messages-as-signatures</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
The trace evaluator</div>
<p class="sd-card-text">Learn more about using the evaluator to validate and debug traces.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../behavioral-topics/topics/evaluator/index.html#evaluator-trace"><span class="std std-ref">The trace evaluator</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Commands in detail</div>
<p class="sd-card-text">Understanding how scopes work is essential to write useful analysis commands.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../structural-topics/topics/commands/index.html#commands"><span class="std std-ref">Commands in detail</span></a></div>
</div>
</section>
<section id="messages-as-tuples">
<h2>Messages as tuples<a class="headerlink" href="#messages-as-tuples" title="Link to this heading">¶</a></h2>
<p>In the previous section we used signatures to encode records, which led to some issues with validation.
However, we can also explore Alloy’s flexible relational logic to implement a
more abstract version that instead of using signatures implements messages directly
as tuples. This has the advantage of avoiding the validation issues, and, by removing message atoms, it will also speed up analysis. The trade off is that it does not
scale very well when we have very complex message types.</p>
<p>Recall that fields in Alloy can be of arbitrary arity, so one can simply declare the
inboxes to return a relation with a set of tuples, each containing all the information of a message: if a message has 2
fields of type <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">A</span></code> and <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">B</span></code>, then the inbox will contain a subset of pairs contained in <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code>. However,
we will also need to identify the type of the message in the inbox. So, if we have different message types, the inbox
should actually contain triples belonging to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code>, where <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Type</span></code> will be an enumerated signature discriminating the different types of messages. Since each inbox is associated
to a node, this would result in a quaternary <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> relation with type <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span> <span class="o">-&gt;</span>
<span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code>. This strategy works if all message types contain exactly the same
payload, otherwise we would need to somehow normalize
this tuple set (more on this later).</p>
<p>In our current example, we have two kinds of messages that happen to have the
same payload, so this strategy can simply be
encoded by changing the declaration of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> to a mutable ternary relation.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Type</span> <span class="o">{}</span>
<span class="k">one</span> <span class="kd">sig</span> <span class="nc">Candidate</span><span class="p">,</span> <span class="nc">Elect</span> <span class="k">extends</span> <span class="nc">Type</span> <span class="o">{}</span>

<span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var </span><span class="n">inbox</span> <span class="p">:</span> <span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Notice that this idiom again disallows repeated messages in the inboxes, since a tuple belonging to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Node</span></code> can only appear once in the inbox.</p>
<p>Specifying the event predicates is actually simpler than the version with explicit messages, since we can always create a new tuple with the needed message payload. So, in the <em>initiate</em> event, the guard just has to check whether the
tuple <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">n</span></code> has ever been in the inbox of the successor, and if
not that ‘message’ is added to the successor’s inbox.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// guard</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">n</span>           <span class="c1">// effect on inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <em>process</em> events are also simpler, and with messages as tuples it is even simpler to specify effects in a point-free style.
The <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">processElected</span></code> event can be specified as follows. Note that now it is again parametrized by the node identifier expected to be contained in the message to be processed.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processElected</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// elected message m is read and processed by node n</span>

  <span class="n">Elect</span><span class="o">-&gt;</span><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// guard</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">Elect</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">Elect</span><span class="o">-&gt;(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n</span><span class="o">)</span>   <span class="c1">// effect on inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The guard states that a message with content <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elect</span><span class="o">-&gt;</span><span class="n">i</span></code> should exist in the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>. In the effect, this message is removed from the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> and only added to the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code> if the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span></code>. This conditional addition is achieved by adding message <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elect</span><span class="o">-&gt;(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n</span><span class="o">)</span></code> to the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code>. Note that <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span> <span class="o">-</span> <span class="n">n</span></code> is empty iff <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span></code>, hence no message will be added in that case.</p>
<p>The specification of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">processCandidate</span></code> can also be done with a couple of one-liners.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">processCandidate</span><span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// candidate msg m is read and processed by node n</span>

  <span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// guard</span>

  <span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">inbox</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">Candidate</span><span class="o">-&gt;(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span><span class="o">)</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">Elect</span><span class="o">-&gt;(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">i</span><span class="o">)</span>   <span class="c1">// effect on inbox</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here we expect a <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">i</span></code> message in the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code>, which is then removed in the effect. The conditional addition of that message to the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span><span class="o">.</span><span class="n">succ</span></code> when <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span></code> is achieved by adding tuple <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Candidate</span><span class="o">-&gt;(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span><span class="o">)</span></code>, and the conditional addition of an elected message when the received identifier is equal to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span></code> is achieved by adding tuple <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elect</span><span class="o">-&gt;(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">i</span><span class="o">)</span></code>, which will be empty iff <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">n</span> <span class="o">!=</span> <span class="n">i</span></code>.</p>
<p>The <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Elected</span></code> function is also simpler.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-&gt;</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="n">Elect</span><span class="o">-&gt;</span><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span> <span class="ow">and</span> <span class="n">Elect</span><span class="o">-&gt;</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Finally, you must update fact <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">events</span></code> and the enabledness predicates for the fairness constraint for this new version of the model. The specification of all properties remains the same, only the commands need to be adapted by removing the scope on <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code>. The specification of the enabledness predicates is the following.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="ow">historically</span> <span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>
<span class="k">pred</span> <span class="nf">processCandidate_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">Candidate</span><span class="o">-&gt;</span><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>
<span class="k">pred</span> <span class="nf">processElected_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">Elect</span><span class="o">-&gt;</span><span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">inbox</span>
<span class="o">}</span>

<span class="k">pred</span> <span class="nf">node_enabled</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">initiate_enabled</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">processCandidate_enabled</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">])</span> <span class="ow">or</span>
  <span class="o">(</span><span class="k">some</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="n">processElected_enabled</span><span class="o">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">])</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In this new model all commands return the expected result. Below is a transition for the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">eventually_elected</span></code>
command.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/40da9924bc7abef72c2bafb6875e9f779230d48a/protocol-design/instance_20/leaderelection.als#L135-L145"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance20.png" style="width: 600px;" />
</a>
<p>Notice that, without messages as signatures, messages are now represented as
edges in the visualizer. In this case, the inbox is a ternary relation <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span> <span class="o">-&gt;</span>
<span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Node</span></code>, so the type appears as an annotation of the edge. This may be
arguably more difficult to interpret than the previous version.</p>
<p>It is also worth noting that the analysis of this version of the model is much
more efficient than the one with explicit messages. Running the
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">at_most_one_leader</span></code> command, whose log was already shown for the other
version, is now one order of magnitude faster than the version with an explicit
<code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Message</span></code> signature.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_most_one_leader</span> <span class="k">for</span> <span class="mi">3</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../../_images/log21.png"><img alt="../../_images/log21.png" class="align-center" src="../../_images/log21.png" style="width: 600px;" />
</a>
<p>The payload of the messages in this protocol
is very simple, with just two message types that happen to contain the
same single, mandatory field. Let us imagine we needed an additional, optional field <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">r</span></code>
with type <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">X</span></code>, in elected messages. With messages as signatures this would be
easy to encode: just add a new <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">lone</span></code> field to the respective message type.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">ElectedMsg</span> <span class="k">extends</span> <span class="nc">Message</span> <span class="o">{</span>
  <span class="n">r</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">X</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Adapting the events is mostly straightforward, just determining the correct
value of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">r</span></code>. However, issues with scope are now exacerbated: the number of
messages must now increase to consider the possibility of an empty <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">r</span></code> (and the
generator axiom must also be adapted to force those cases).</p>
<p>In the messages as tuples idiom, we must now adapt the declaration of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> so that it always contain tuples with the same arity. Elected
messages with an <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">r</span></code> are quaternary tuples of type <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span> <span class="o">-&gt;</span> <span class="n">Type</span> <span class="o">-&gt;</span>
<span class="n">Node</span> <span class="o">-&gt;</span> <span class="n">X</span></code>, while all other messages are of type <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node</span> <span class="o">-&gt;</span> <span class="n">Type</span> <span class="o">-&gt;</span>
<span class="n">Node</span></code>. To make all tuples of the same arity, we could introduce an <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Empty</span></code> singleton signature to pad the tuples of the messages with less content. In particular,  it will
always be the forth element of candidate messages of
elected messages without the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">r</span></code> field. The declaration of the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">inbox</span></code> would look as follows.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="kd">sig</span> <span class="nc">Type</span> <span class="o">{}</span>
<span class="k">one</span> <span class="kd">sig</span> <span class="nc">Candidate</span><span class="p">,</span> <span class="nc">Elect</span> <span class="k">extends</span> <span class="nc">Type</span> <span class="o">{}</span>

<span class="k">one</span> <span class="kd">sig</span> <span class="nc">Empty</span> <span class="o">{}</span>

<span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var </span><span class="n">inbox</span> <span class="p">:</span> <span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">Id</span> <span class="o">-&gt;</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Empty</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Using tuples to direct represent messages has many advantages as we have seen. Unfortunately, if messages have a lot of different fields it will not scale up, due to the wat the analysis of Alloy models is performed. Fields of arity <span class="math notranslate nohighlight">\(n\)</span> might require <span class="math notranslate nohighlight">\(2^{n^2}\)</span> boolean variables in the backend analysis engine, and this value becomes too large for larger values of <span class="math notranslate nohighlight">\(n\)</span>.</p>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-file-badge" viewBox="0 0 16 16" aria-hidden="true"><path d="M2.75 1.5a.25.25 0 0 0-.25.25v11.5c0 .138.112.25.25.25h3.5a.75.75 0 0 1 0 1.5h-3.5A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8a1.75 1.75 0 0 1 1.508.862.75.75 0 1 1-1.289.768.25.25 0 0 0-.219-.13h-8Z"></path><path d="M8 7a3.999 3.999 0 0 1 7.605-1.733 4 4 0 0 1-1.115 4.863l.995 4.973a.75.75 0 0 1-.991.852l-2.409-.876a.248.248 0 0 0-.17 0l-2.409.876a.75.75 0 0 1-.991-.852l.994-4.973A3.994 3.994 0 0 1 8 7Zm4-2.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm0 6.5c-.373 0-.745-.051-1.104-.154l-.649 3.243 1.155-.42c.386-.14.81-.14 1.196 0l1.155.42-.649-3.243A4.004 4.004 0 0 1 12 11Z"></path></svg> Alloy model</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Full model for the section</div>
<p class="sd-card-text">Download and explore the files relevant for the model at this point of the book.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference external" href="https://github.com/practicalalloy/models/tree/main/protocol-design/messages-as-tuples"><span>https://github.com/practicalalloy/models/tree/main/protocol-design/messages-as-tuples</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Model finding</div>
<p class="sd-card-text">Learn how the analysis engine of Alloy works, to understand why analysis becomes unfeasible with fields of large arity.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../structural-topics/topics/model-finding/index.html#analysis"><span class="std std-ref">Model finding</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Higher-arity relations</div>
<p class="sd-card-text">In this section we used higher-arity fields to model inboxes. Learn how to use them.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../structural-topics/topics/nary-relations/index.html#nary-relations"><span class="std std-ref">Higher-arity relations</span></a></div>
</div>
</section>
<section id="refining-the-network-model">
<h2>Refining the network model<a class="headerlink" href="#refining-the-network-model" title="Link to this heading">¶</a></h2>
<p>So far we’ve considered node inboxes to be sets, meaning that received messages are unordered and thus not necessarily processed in the delivery order. This allows us to show that our protocol is correct in a network model where there are no guarantees or ordered delivery.
However, we might want to verify the correctness of our protocol in a more refined network model, closer to a possible implementation. For example, some middlewares ensure ordered delivery, but only support inboxes with a maximum size, meaning that if a message is received while the inbox is still full it will be silently discarded. If we wanted to check the correctness of our protocol with this network model, we would need to model inboxes using bounded queues, which can be done by resorting to Alloy sequences. To simplify the presentation, we will illustrate this by building on one of the simpler models of our protocol, where only the first phase was specified using a point-wise style, and where messages where just node identifiers.</p>
<p>Sequences in Alloy are introduced with the keyword <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">seq</span></code>, and are essentially partial functions from integer indices to elements of the specified type. The scope of indices is bounded, meaning that sequences cannot grow indefinitely. Changing our inboxes to (mutable) sequences results in the following signature declaration.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="kd">sig</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="n">next</span> <span class="p">:</span> <span class="k">lone</span> <span class="n">Node</span><span class="p">,</span>
  <span class="n">succ</span> <span class="p">:</span> <span class="k">one</span> <span class="n">Node</span><span class="p">,</span>
  <span class="k">var </span><span class="n">inbox</span> <span class="p">:</span> <span class="k">seq</span> <span class="n">Node</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To adapt the events, we can make use of the auxiliary functions provided by utility module <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">sequniv</span></code> (which is imported automatically whenever sequences are used). But first, the Analyzer will throw an ambiguity error in our <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">ordering</span></code> do to a call to our <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">first</span></code> signature that clashes with a function defined in <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">sequniv</span></code>. To disambiguate, just replace it with <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="k">this</span><span class="o">/</span><span class="n">first</span></code>.</p>
<p>Writing the events in the point-free style is complicated when sequence operations are involved, so let us adapt the point-wise version previously presented. To test whether a message is already in the inbox of the successor in the guard of the <em>initiate</em> event, one can use <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">elems</span></code> to get all elements in a sequence. To add a new message to an inbox, one can use function <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">add</span></code> to add an element to the end of a sequence. If the sequence is already full, <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">add</span></code> discards the new element and returns the sequence unchanged.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">initiate</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// node n initiates the protocol</span>

  <span class="ow">historically</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elems</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>    <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">add</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="p">,</span> <span class="n">n</span><span class="o">]</span>         <span class="c1">// effect on n.succ.inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>   <span class="c1">// effect on the outboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <em>process</em> event can be adapted in a similar manner. Rather than selecting an arbitrary message from the inbox, it now must select the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">first</span></code> element in the sequence, and then update the inbox by keeping only the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">rest</span></code> of the sequence. When propagating the message, is it also added to the successor’s inbox with <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">add</span></code>.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">pred</span> <span class="nf">process</span> <span class="o">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Node</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// i is read and processed by node n</span>

  <span class="n">i</span> <span class="ow">in</span> <span class="n">first</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>                                       <span class="c1">// guard</span>

  <span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">rest</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span>                                  <span class="c1">// effect on n.inbox</span>
  <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.^</span><span class="n">next</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">add</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="p">,</span> <span class="n">i</span><span class="o">]</span> <span class="c1">// effect on n.succ.inbox</span>
               <span class="k">else</span>    <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">implies</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span><span class="o">.</span><span class="n">inbox</span>
  <span class="k">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">.</span><span class="n">succ</span> <span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span><span class="o">&#39;</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">inbox</span>            <span class="c1">// effect on the inboxes of other nodes</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Finally, we must adapt the notion of elected node. We’ll just say that a node is considered to be elected when its own identifier was at the head of its inbox and processed in the next state.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">Elected</span> <span class="p">:</span> <span class="k">set</span> <span class="n">Node</span> <span class="o">{</span>
  <span class="o">{</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="ow">once</span> <span class="o">(</span><span class="ow">before</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">first</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">]</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">first</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="n">inbox</span><span class="o">])</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>At this point our leader election model with queues can be validated, and the previously defined safety and liveness properties will still be valid for a default scope of 3. However, this version of the protocol will actually not work if the capacity of the inboxes is less than the number of nodes. In particular it is no longer guaranteed that a leader will be elected. This can be checked with the following command.</p>
<div class="highlight-practicalalloy notranslate"><div class="highlight"><pre><span></span><span class="k">check</span> <span class="n">at_least_one_leader_fair</span> <span class="k">for</span> <span class="mi">3</span> <span class="k">but</span> <span class="mi">2</span> <span class="k">seq</span>
</pre></div>
</div>
<p>This will now return a counter-example, for which a relevant transition is shown below.</p>
<a class="reference external image-reference" href="https://github.com/practicalalloy/models/blob/40da9924bc7abef72c2bafb6875e9f779230d48a/protocol-design/instance_21/leaderelection.als#L126-L136"><img alt="Get the code to generate this instance." class="align-center" src="../../_images/instance211.png" style="width: 600px;" />
</a>
<p>The issue is that the inbox of <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node2</span></code>, the potential leader, is already at full capacity. <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node0</span></code> is attempting to send the <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node2</span></code> identifier to <code class="code highlight alloy practicalalloy docutils literal highlight-practicalalloy"><span class="n">Node2</span></code>, but since the queue is already full, the message is discarded. So to ensure liveness in this version of the protocol - and in an eventual implementation with such a communication middleware - one must make sure that the inboxes are large enough to contain all possible messages. Although this counter-example uses very small queues sizes, the problem still might exist in realistic implementations at larger scales.</p>
<div class="sd-sphinx-override sd-cards-carousel sd-card-cols-2 docutils">
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-file-badge" viewBox="0 0 16 16" aria-hidden="true"><path d="M2.75 1.5a.25.25 0 0 0-.25.25v11.5c0 .138.112.25.25.25h3.5a.75.75 0 0 1 0 1.5h-3.5A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8a1.75 1.75 0 0 1 1.508.862.75.75 0 1 1-1.289.768.25.25 0 0 0-.219-.13h-8Z"></path><path d="M8 7a3.999 3.999 0 0 1 7.605-1.733 4 4 0 0 1-1.115 4.863l.995 4.973a.75.75 0 0 1-.991.852l-2.409-.876a.248.248 0 0 0-.17 0l-2.409.876a.75.75 0 0 1-.991-.852l.994-4.973A3.994 3.994 0 0 1 8 7Zm4-2.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm0 6.5c-.373 0-.745-.051-1.104-.154l-.649 3.243 1.155-.42c.386-.14.81-.14 1.196 0l1.155.42-.649-3.243A4.004 4.004 0 0 1 12 11Z"></path></svg> Alloy model</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Full model for the section</div>
<p class="sd-card-text">Download and explore the files relevant for the model at this point of the book.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference external" href="https://github.com/practicalalloy/models/tree/main/protocol-design/refining-the-network-model"><span>https://github.com/practicalalloy/models/tree/main/protocol-design/refining-the-network-model</span></a></div>
<div class="sd-card sd-sphinx-override sd-mb-3 sd-shadow-sm sd-card-hover docutils">
<div class="sd-card-header docutils">
<p class="sd-card-text"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-beaker" viewBox="0 0 16 16" aria-hidden="true"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"></path></svg> Further reading</p>
</div>
<div class="sd-card-body docutils">
<div class="sd-card-title sd-font-weight-bold docutils">
Sequences</div>
<p class="sd-card-text">Sequences in Alloy have some particularities, learn how to use them correctly.</p>
</div>
<a class="sd-stretched-link sd-hide-link-text reference internal" href="../behavioral-topics/topics/sequences/index.html#sequences"><span class="std std-ref">Sequences</span></a></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../../bibliography.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Bibliography</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../behavioral-topics/topics/sequences/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Sequences</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021-2025, Alcino Cunha, Nuno Macedo, Julien Brunel, David Chemouil
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Feb 04, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Protocol design</a><ul>
<li><a class="reference internal" href="#specifying-the-network-configuration">Specifying the network configuration</a></li>
<li><a class="reference internal" href="#specifying-the-protocol-dynamics">Specifying the protocol dynamics</a></li>
<li><a class="reference internal" href="#verifying-the-expected-properties">Verifying the expected properties</a></li>
<li><a class="reference internal" href="#making-the-specification-more-abstract">Making the specification more abstract</a></li>
<li><a class="reference internal" href="#explicit-messages-as-signatures">Explicit messages as signatures</a></li>
<li><a class="reference internal" href="#messages-as-tuples">Messages as tuples</a></li>
<li><a class="reference internal" href="#refining-the-network-model">Refining the network model</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=10f1778b"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "practicalalloy/practicalalloy.github.io");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "💬 comment");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>